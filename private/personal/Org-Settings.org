* Introduction
I've decided to just store all of my org-mode settings in a single file within
the personal layer. As a matter of fact, I think all of my personal
configurations will go in here from now on, so that
- They will always be under version control
- I'll have be able to look and reassure myself of certain decisions I make
  regarding my configs, so writing them up in a literate style is good for me.
All that being said, I will now begin my descent into describing my org-mode
settings.
* Config
The file paths to my various org-files will go here. I use Claus Witt's settings
as a model, I'll probably expland upon or reduce this as time goes on, but here
are the six paths.

- /org-dir/ where all org files are stored.
- /gtd-inbox/ where newly created tasks go after an org capture
- /inbox-txt/ a hold over from Claus, this is where the txt version of my inbox
  is stored.
- /gtd/ this is the gtd directory where my main task and update files go
- /journal/ where I write down ideas and thoughts. I don't do much here because
  I write physical morning pages, so this may or may not get used.
- /notes/ snippets and notes
- /groceries/ where I store grocery lists, though I usually let Kat do it.

** Folders  
#+begin_src emacs-lisp :tangle "~/.emacs.d/private/personal/funcs.el" :noweb
  (defun open-org-dir ()
    "Opens the org dir"
    (interactive)
    (find-file "~/Dropbox/org/")
    )
  (defun gtd-inbox ()
    "Open the gtd inbox"
    (interactive)
    (find-file "~/Dropbox/org/inbox.org")
    )
  (defun gtd-inbox-txt ()
    "Open the gtd inbox"
    (interactive)
    (find-file "~/Dropbox/org/inbox.org.txt")
    )
  (defun gtd ()
    "Open GTD directory"
    (interactive)
    (find-file "~/Dropbox/org/gtd/main.org")
    )
  (defun journal ()
    "Open Journal"
    (interactive)
    (find-file "~/Dropbox/org/journal.org")
    )
  (defun notes ()
    "Switch to my work dir."
    (interactive)
    (find-file "~/Dropbox/org/notes/")
    )
  (defun groceries ()
    "Edit grocery list"
    (interactive)
    (find-file "~/Dropbox/org/groceries.org")
    )

  (defun my-org-archive-done-tasks ()
    (interactive)
    (org-map-entries 'org-archive-subtree "/DONE" 'file)
    )
#+end_src

 Now to point the org files to the proper directory.
#+begin_src emacs-lisp :tangle "~/.emacs.d/private/personal/config.el" :noweb
(setq org-directory "~/Dropbox/org/")
#+end_src
Were also going to go ahead and define our capture templates here. I only have
them for Inbox, Groceries, and Journal entries. Will add more later.

#+begin_src emacs-lisp :tangle "~/.emacs.d/private/personal/config.el" :noweb
  (setq org-capture-templates
        '(("i" "Inbox" entry (file "~/Dropbox/org/inbox.org")
           "** TODO %?\n %i\n %a")
          ("t" "Todo" entry (file+headline "~/Dropbox/org/gtd/private.org" "Tasks")
           "* TODO %?\n %i\n %a")
          ("g" "Groceries" entry (file+headline "~/Dropbox/org/groceries.org" "INBOX")
           "* %?\n %i\n %a")
          ("j" "Journal Entry" entry (file+datetree "~/Dropbox/org/journal.org")
           "* %?\nEntered on %U\n %i\n %a")
          )
        )
#+end_src
** DONE org-setup
CLOSED: [2015-06-15 Mon 22:01]
- State "DONE"       from "TODO"       [2015-06-15 Mon 22:01]
#+begin_src emacs-lisp :tangle "~/.emacs.d/private/personal/config.el" :noweb
  ;; Org settings
  (setq fill-column 64)
  (setq visual-line-mode nil)
  (setq org-directory "~/Dropbox/org/")
  (setq org-agenda-files '("~/Dropbox/org/"
                           "~/Dropbox/org/gtd"
                           "~/Dropbox/org/notes"
                           "~/Dropbox/org/writing/project1"
                           ))
  ;; The habit package for org is awesome!
  ;; Ifttt auto appends .txt to filenames for dropbox append to file action
  (add-to-list 'auto-mode-alist '("\\Dropbox/org/.*\.txt\\'" . org-mode))

#+end_src
** DONE org-agenda keywords 
CLOSED: [2015-06-15 Mon 20:37]
- State "DONE"       from "TODO"       [2015-06-15 Mon 20:37]
I use two models for keywords here. The first is Tony Ballantyne's writing
sequences, the second one is a set of sequences that will be used generally in
org-mode. Its best to collect all of the todo stuff together, for convenience,
and because you can only do one setq.
#+begin_src emacs-lisp :tangle "~/.emacs.d/private/personal/config.el" :noweb
  (setq org-todo-keywords
        (quote ((sequence "TODO(t!)"  "NEXT(n!)" "STARTED(s!)" "APPT(a!)" "|" "DONE(d!)")
                (sequence "REPEAT(r)"  "WAITING(w!)" "HOLD(h!)" "|"  "PAUSED(p@/!)" "CANCELLED(c@/!)" )
                (sequence "IDEA(i!)" "MAYBE(y!)" "STAGED(s!)" "WORKING(k!)" "|" "USED(u!/@)")
                )))
#+end_src
** DONE org-refile settings
CLOSED: [2015-06-15 Mon 21:45]
- State "DONE"       from "TODO"       [2015-06-15 Mon 21:45]
Add completion... Hmm.
#+begin_src emacs-lisp :tangle "~/.emacs.d/private/personal/config.el" :noweb
  ;Use IDO for both buffer and file completion and ido-everywhere to t
  (setq org-completion-use-ido t)
  (setq ido-everywhere t)
  (setq ido-max-directory-size 100000)
  (ido-mode (quote both))

  ; Use the current window when visiting files and buffers with ido
  (setq ido-default-file-method 'selected-window)
  (setq ido-default-buffer-method 'selected-window)
#+end_src
And lets set some refile targets.
#+begin_src emacs-lisp :tangle "~/.emacs.d/private/personal/config.el" :noweb
  ;; Quick searches in org mode
  ; Targets include this file and any file contributing to the agenda - up to 9 levels deep
  (setq org-refile-targets (quote ((nil :maxlevel . 9)
                                   (org-agenda-files :maxlevel . 9))))
  ; Use full outline paths for refile targets - we file directly with IDO
  (setq org-refile-use-outline-path t)

  ; Targets complete directly with IDO
  (setq org-outline-path-complete-in-steps nil)

  ; Allow refile to create parent tasks with confirmation
  (setq org-refile-allow-creating-parent-nodes (quote confirm))
#+end_src

Exclude DONE state tasks from refile targets
#+begin_src emacs-lisp :tangle "~/.emacs.d/private/personal/funcs.el" :noweb
  (setq org-indirect-buffer-display 'current-window)
  (defun bh/verify-refile-target ()
    "Exclude todo keywords with a done state from refile targets"
    (not (member (nth 2 (org-heading-components)) org-done-keywords)))
  (setq org-refile-target-verify-function 'bh/verify-refile-target)
#+end_src
** org-agenda settings
This is perhaps the meat of my org file, dealing with agenda settings. First we
need to tell org-mode where to find my org-agenda-files. We're also going to
make it a list so that we can add more directories as time goes on. I'm working
on a novel, so this is ideal because even though I would love to put everything
in my dropbox, I'd prefer to keep my writing files under another form of source
control, particularly so I can revert to a previous version if something goes
horribly wrong. Its overkill, yes, but worth it.

State tag triggers.
#+begin_src emacs-lisp :tangle "~/.emacs.d/private/personal/config.el" :noweb
  (setq org-todo-state-tags-triggers
        (quote (("CANCELLED" ("CANCELLED" . t))
                ("WAITING" ("WAITING" . t))
                ("HOLD" ("WAITING") ("HOLD" . t))
                (done ("WAITING") ("HOLD"))
                ("TODO" ("WAITING") ("CANCELLED") ("HOLD"))
                ("NEXT" ("WAITING") ("CANCELLED") ("HOLD"))
                ("DONE" ("WAITING") ("CANCELLED") ("HOLD")))))
#+end_src
Evil-leader keybindings
#+begin_src emacs-lisp :tangle "~/.emacs.d/private/personal/keybindings.el" :noweb
  ;; Org-mode keybindings
  (evil-leader/set-key "oo" 'open-org-dir)
  (evil-leader/set-key "oa" 'my-org-archive-done-tasks)
  (evil-leader/set-key "og" 'gtd)
  (evil-leader/set-key "oj" 'journal)
  (evil-leader/set-key "ot" 'org-capture)
  (evil-leader/set-key "on" 'notes)
  (evil-leader/set-key "oG" 'groceries)
  (evil-leader/set-key "oi" 'gtd-inbox)
  (evil-leader/set-key "oI" 'gtd-inbox-txt)
  (evil-leader/set-key "oU" 'org-mobile-push)
  (evil-leader/set-key "oD" 'org-mobile-pull)
  (evil-leader/set-key "oek" 'edit-personal-keybindings)
  (evil-leader/set-key "oef" 'edit-personal-funcs)
  (evil-leader/set-key "of" 'ff-find-other-file)
  (evil-leader/set-key "*y" 'clipboard-kill-region)
  (evil-leader/set-key "*p" 'clipboard-yank)

#+end_src
Mode defaults for agenda
#+begin_src emacs-lisp :tangle "~/.emacs.d/private/personal/keybindings.el" :noweb
  (defun custom-org-agenda-mode-defaults ()
    (org-defkey org-agenda-mode-map "W" 'oh/agenda-remove-restriction)
    (org-defkey org-agenda-mode-map "N" 'oh/agenda-restrict-to-subtree)
    (org-defkey org-agenda-mode-map "P" 'oh/agenda-restrict-to-project)
    (org-defkey org-agenda-mode-map "q" 'bury-buffer)
    (org-defkey org-agenda-mode-map "I" 'org-clock-in)
    (org-defkey org-agenda-mode-map "O" 'org-clock-out)
    )
#+end_src
** org-helpers
Org helper stuff
#+begin_src emacs-lisp :tangle "~/.emacs.d/private/personal/org-helpers.el" :noweb
  (defmacro oh/agenda-type (&rest types)
    `(or ,@(mapcar '(lambda (item)
                     (let ((type (symbol-name (if (listp item)
                                                  (car (cdr item))
                                                item))))
                       `(,(intern (concat "oh/is-" type "-p")))))
                  types)))

  (defun* oh/agenda-skip (&rest types
                          &key ((:headline-if headline) nil)
                               ((:headline-if-restricted-and headline-restricted) nil)
                               ((:headline-if-unrestricted-and headline-unrestricted) nil)
                               ((:subtree-if subtree) nil)
                               ((:subtree-if-restricted-and subtree-restricted) nil)
                               ((:subtree-if-unrestricted-and subtree-unrestricted) nil))
    "True when one of the given check functions return true."
    (save-restriction
      (let* ((subtree-values (or types subtree))
             (subtree-end (save-excursion (org-end-of-subtree t)))
             (next-headline (save-excursion (or (outline-next-heading)
                                                (point-max))))
             (restricted-to-project (marker-buffer org-agenda-restrict-begin)))
        (cond
         ((and headline
               (eval (macroexpand `(oh/agenda-type ,@headline))))
          next-headline)
         ((and subtree
               (eval (macroexpand `(oh/agenda-type ,@subtree))))
          subtree-end)
         ((and headline-restricted
               restricted-to-project
               (eval (macroexpand `(oh/agenda-type ,@headline-restricted))))
          next-headline)
         ((and headline-unrestricted
               (not restricted-to-project)
               (eval (macroexpand `(oh/agenda-type ,@headline-unrestricted))))
          next-headline)
         ((and subtree-restricted
               restricted-to-project
               (eval (macroexpand `(oh/agenda-type ,@subtree-restricted))))
          subtree-end)
         ((and subtree-unrestricted
               (not restricted-to-project)
               (eval (macroexpand `(oh/agenda-type ,@subtree-unrestricted))))
          subtree-end)
         (t nil)))))

  (defun oh/has-subtask-p ()
    "Returns t for any heading that has subtasks."
    (save-restriction
      (widen)
      (org-back-to-heading t)
      (let ((end (save-excursion (org-end-of-subtree t))))
        (outline-end-of-heading)
        (save-excursion
          (re-search-forward (concat "^\*+ " org-todo-regexp) end t)))))

  (defun oh/has-parent-project-p ()
    "Returns t when current heading has a parent project."
    (let ((has-parent nil))
      (while (and (not has-parent) (org-up-heading-safe))
        (when (oh/is-todo-p)
          (setq has-parent t)))
      has-parent))

  (defun oh/is-todo-p ()
    "Returns t for any heading that has a todo keyword."
    (member (org-get-todo-state) org-todo-keywords-1))

  (defun oh/is-project-p ()
    "Returns t for any heading that is a todo item and that has a subtask."
    (and (oh/is-todo-p)
         (oh/has-subtask-p)))

  (defun oh/is-non-project-p ()
    "Returns t for any heading that is not a project.  E.g. that does not
     have a subtask or is not a todo item."
    (not (oh/is-project-p)))

  (defun oh/is-stuck-project-p ()
    "Returns t for any heading that is a project but does not have a NEXT
     subtask but has TODO subtasks."
    (save-excursion
      (let ((end (save-excursion (org-end-of-subtree t))))
        (outline-end-of-heading)
        (and (oh/is-project-p)
             (not (save-excursion (re-search-forward "^\\*+ \\(NEXT\\|STARTED\\) " end t)))
             (re-search-forward "^\\*+ TODO " end t)))))

  (defun oh/is-non-stuck-project-p ()
    "Returns t for any heading that is a project and has a `NEXT` subtask."
    (save-excursion
      (let ((end (save-excursion (org-end-of-subtree t))))
        (outline-end-of-heading)
        (and (oh/is-project-p)
             (or (save-excursion (re-search-forward "^\\*+ \\(NEXT\\|STARTED\\) " end t))
                 (not (re-search-forward "^\\*+ TODO " end t)))))))

  (defun oh/is-subproject-p ()
    "Returns t for any heading that is a project and has a parent project."
    (and (oh/is-project-p)
         (oh/has-parent-project-p)))

  (defun oh/is-top-project-p ()
    "Returns t when current heading is not a subproject."
    (and (oh/is-project-p)
         (not (oh/has-parent-project-p))))

  (defun oh/is-task-p ()
    "Returns t for any heading that is a todo item but does not have a subtask."
    (and (oh/is-todo-p)
         (not (oh/has-subtask-p))))

  (defun oh/is-subtask-p ()
    "Returns t for any heading that is a task with a parent project."
    (and (oh/is-task-p)
         (oh/has-parent-project-p)))

  (defun oh/is-single-task-p ()
    "Returns t for any heading that is a task without a parent project."
    (and (oh/is-task-p)
         (not (oh/has-parent-project-p))))

  (defun oh/is-habit-p ()
    "Returns t for any heading that is a habit."
    (org-is-habit-p))

  (defun oh/is-inactive-p ()
    "Returns t for any heading that is of todo state `SOMEDAY`, `HOLD`,
  `WAITING`, `DONE` or `CANCELLED`. This also applys to headings that
  have parent headings that are of those given todo states."
    (save-excursion
      (let ((is-inactive (member (org-get-todo-state) '("SOMEDAY" "HOLD" "WAITING" "CANCELLED" "DONE"))))
        (while (and (not is-inactive) (org-up-heading-safe))
          (when (member (org-get-todo-state) '("SOMEDAY" "HOLD" "WAITING" "CANCELLED" "DONE"))
            (setq is-inactive t)))
        is-inactive)))

  (defun oh/is-inactive-project-p ()
    "Returns t for any heading that is of todo state `SOMEDAY`, `HOLD`,
  `WAITING`, `DONE` or `CANCELLED` or if there is no TODO entry.
  This also applys to headings that have parent headings that are of those
  given todo states."
    (save-excursion
      (let* ((is-inactive (member (org-get-todo-state) '("SOMEDAY" "HOLD" "WAITING" "CANCELLED" "DONE")))
             (end (save-excursion (org-end-of-subtree t)))
             (is-inactive (or is-inactive
                              (save-excursion (not (re-search-forward "^\\*+ \\(TODO\\|NEXT\\) " end t))))))
        (while (and (not is-inactive) (org-up-heading-safe))
          (when (member (org-get-todo-state) '("SOMEDAY" "HOLD" "WAITING" "CANCELLED" "DONE"))
            (setq is-inactive t)))
        is-inactive)))

  (defun oh/is-scheduled-p ()
    "Returns t for any scheduled heading."
    (org-back-to-heading t)
    (let ((end (save-excursion (outline-next-heading) (1- (point)))))
      (re-search-forward org-scheduled-time-regexp end t)))

  (defun oh/is-deadline-p ()
    "Returns t for any heading with a deadline."
    (org-back-to-heading t)
    (let ((end (save-excursion (outline-next-heading) (1- (point)))))
      (re-search-forward org-deadline-time-regexp end t)))

  ;;; MOVEMENT HELPERS
  ;; To move easily between headings.

  (defun oh/find-toplevel-project ()
    "Moves the point to the top project of the current headline, if any ..."
    (save-restriction
      (widen)
      (let ((project-point (point)))
        (while (org-up-heading-safe)
          (if (oh/is-todo-p)
              (setq project-point (point))))
        (goto-char project-point)
        project-point)))

  (defun oh/show-toplevel-project ()
    "Switches to the toplevel project of a task."
    (interactive)
    (if (equal major-mode 'org-agenda-mode)
        (org-agenda-switch-to))
    (oh/find-toplevel-project))

  ;;; AGENDA RESTRICTION
  ;; To provide easy context switches and better overview.

  (defun oh/agenda-set-restriction ()
    "Sets the restriction lock for a subtree."
    (interactive)
    (org-narrow-to-subtree)
    (org-agenda-set-restriction-lock))

  (defun oh/agenda-remove-restriction ()
    "Removes the restriction lock for a subtree."
    (interactive)
    (widen)
    (org-agenda-remove-restriction-lock))

  (defun oh/agenda-restrict-to-subtree ()
    "Restricts the agenda view to the subtree of the current heading."
    (interactive)
    (if (equal major-mode 'org-agenda-mode)
        (org-with-point-at (org-get-at-bol 'org-hd-marker)
          (oh/agenda-set-restriction))
      (oh/agenda-set-restriction)))

  (defun oh/agenda-restrict-to-project ()
    "Restricts the agenda view to the top level project of the current heading."
    (interactive)
    (widen)
    (save-excursion
      (if (equal major-mode 'org-agenda-mode)
          (org-with-point-at (org-get-at-bol 'org-hd-marker)
            (oh/find-toplevel-project)
            (oh/agenda-set-restriction))
        (progn
          (oh/find-toplevel-project)
          (oh/agenda-set-restriction)))))


  (defun oh/agenda-sort (a b)
    "Sorting strategy for agenda items.
  Late deadlines first, then scheduled, then non-late deadlines"
    (let (result num-a num-b)
      (cond
       ;; time specific items are already sorted first by org-agenda-sorting-strategy
       ;; non-deadline and non-scheduled items next
       ((oh/agenda-sort-test 'oh/is-not-scheduled-or-deadline a b))
       ;; deadlines for today next
       ((oh/agenda-sort-test 'oh/is-due-deadline a b))
       ;; late deadlines next
       ((oh/agenda-sort-test-num 'oh/is-late-deadline '< a b))
       ;; scheduled items for today next
       ((oh/agenda-sort-test 'oh/is-scheduled-today a b))
       ;; late scheduled items next
       ((oh/agenda-sort-test-num 'oh/is-scheduled-late '> a b))
       ;; pending deadlines last
       ((oh/agenda-sort-test-num 'oh/is-pending-deadline '< a b))
       ;; finally default to unsorted
       (t (setq result nil)))
      result))

  (defmacro oh/agenda-sort-test (fn a b)
    "Test for agenda sort"
    `(cond
      ;; if both match leave them unsorted
      ((and (apply ,fn (list ,a))
            (apply ,fn (list ,b)))
       (setq result nil))
      ;; if a matches put a first
      ((apply ,fn (list ,a))
       (setq result -1))
      ;; otherwise if b matches put b first
      ((apply ,fn (list ,b))
       (setq result 1))
      ;; if none match leave them unsorted
      (t nil)))

  (defmacro oh/agenda-sort-test-num (fn compfn a b)
    `(cond
      ((apply ,fn (list ,a))
       (setq num-a (string-to-number (match-string 1 ,a)))
       (if (apply ,fn (list ,b))
           (progn
             (setq num-b (string-to-number (match-string 1 ,b)))
             (setq result (if (apply ,compfn (list num-a num-b))
                              -1
                            1)))
         (setq result -1)))
      ((apply ,fn (list ,b))
       (setq result 1))
      (t nil)))

  (defun oh/is-not-scheduled-or-deadline (date-str)
    (and (not (oh/is-deadline date-str))
         (not (oh/is-scheduled date-str))))

  (defun oh/is-due-deadline (date-str)
    (string-match "Deadline:" date-str))

  (defun oh/is-late-deadline (date-str)
    (string-match "In *\\(-.*\\)d\.:" date-str))

  (defun oh/is-pending-deadline (date-str)
    (string-match "In \\([^-]*\\)d\.:" date-str))

  (defun oh/is-deadline (date-str)
    (or (oh/is-due-deadline date-str)
        (oh/is-late-deadline date-str)
        (oh/is-pending-deadline date-str)))

  (defun oh/is-scheduled (date-str)
    (or (oh/is-scheduled-today date-str)
        (oh/is-scheduled-late date-str)))

  (defun oh/is-scheduled-today (date-str)
    (string-match "Scheduled:" date-str))

  (defun oh/is-scheduled-late (date-str)
    (string-match "Sched\.\\(.*\\)x:" date-str))

  ;;; MISC HELPERS

  (defun oh/summary-todo-checkbox (c-on c-off)
    "Switch entry to DONE when all subentry-checkboxes are done,
  to TODO otherwise."
    (outline-previous-visible-heading 1)
    (let (org-log-done org-log-states)
      (org-todo (if (= c-off 0) "DONE" "TODO"))))

  (provide 'org-helpers)
#+end_src
** TODO org-tags

